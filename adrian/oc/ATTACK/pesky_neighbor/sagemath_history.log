$ docker restart 739818dc527595f872
739818dc527595f872
$ docker exec -it 739818dc527595f872 /usr/local/bin/sage-entrypoint sage
┌────────────────────────────────────────────────────────────────────┐
│ SageMath version 10.4, Release Date: 2024-07-19                    │
│ Using Python 3.12.4. Type "help()" for help.                       │
└────────────────────────────────────────────────────────────────────┘
sage: %history -g
 1/1:
from sage.all import GF

x = GF(2)["x"].gen()
gf2e = GF(2 ** 128, name="y", modulus=x ** 128 + x ** 7 + x ** 2 + x + 1)


# Converts an integer to a gf2e element, little endian.
def _to_gf2e(n):
    return gf2e([(n >> i) & 1 for i in range(127, -1, -1)])


# Converts a gf2e element to an integer, little endian.
def _from_gf2e(p):
    n = p.integer_representation()
    ans = 0
    for i in range(128):
        ans <<= 1
        ans |= ((n >> i) & 1)

    return ans


# Calculates the GHASH polynomial.
def _ghash(h, a, c):
    la = len(a)
    lc = len(c)
    p = gf2e(0)
    for i in range(la // 16):
        p += _to_gf2e(int.from_bytes(a[16 * i:16 * (i + 1)], byteorder="big"))
        p *= h

    if la % 16 != 0:
        p += _to_gf2e(int.from_bytes(a[-(la % 16):] + bytes(16 - la % 16), byteorder="big"))
        p *= h

    for i in range(lc // 16):
        p += _to_gf2e(int.from_bytes(c[16 * i:16 * (i + 1)], byteorder="big"))
        p *= h

    if lc % 16 != 0:
        p += _to_gf2e(int.from_bytes(c[-(lc % 16):] + bytes(16 - lc % 16), byteorder="big"))
        p *= h

    p += _to_gf2e(((8 * la) << 64) | (8 * lc))
    p *= h
    return p


def recover_possible_auth_keys(a1, c1, t1, a2, c2, t2):
    """
    Recovers possible authentication keys from two messages encrypted with the same authentication key.
    More information: Joux A., "Authentication Failures in NIST version of GCM"
    :param a1: the associated data of the first message (bytes)
    :param c1: the ciphertext of the first message (bytes)
    :param t1: the authentication tag of the first message (bytes)
    :param a2: the associated data of the second message (bytes)
    :param c2: the ciphertext of the second message (bytes)
    :param t2: the authentication tag of the second message (bytes)
    :return: a generator generating possible authentication keys (gf2e element)
    """
    h = gf2e["h"].gen()
    p1 = _ghash(h, a1, c1) + _to_gf2e(int.from_bytes(t1, byteorder="big"))
    p2 = _ghash(h, a2, c2) + _to_gf2e(int.from_bytes(t2, byteorder="big"))
    for h, _ in (p1 + p2).roots():
        yield h


def forge_tag(h, a, c, t, target_a, target_c):
    """
    Forges an authentication tag for a target message given a message with a known tag.
    This method is best used with the authentication keys generated by the recover_possible_auth_keys method.
    More information: Joux A., "Authentication Failures in NIST version of GCM"
    :param h: the authentication key to use (gf2e element)
    :param a: the associated data of the message with the known tag (bytes)
    :param c: the ciphertext of the message with the known tag (bytes)
    :param t: the known authentication tag (bytes)
    :param target_a: the target associated data (bytes)
    :param target_c: the target ciphertext (bytes)
    :return: the forged authentication tag (bytes)
    """
    ghash = _from_gf2e(_ghash(h, a, c))
    target_ghash = _from_gf2e(_ghash(h, target_a, target_c))
    return (ghash ^ int.from_bytes(t, byteorder="big") ^ target_ghash).to_bytes(16, byteorder="big")
 1/2: from Crypto.Utils.number import *
 1/3: !pip install pycryptodome
 1/4: from Crypto.Utils.number import *
 1/5: from Crypto.Util.number import *
 1/6: long_to_bytes(0xf3f38a716511b3bbbc253c6992e3fe692d709354c0b7c82a9f1be40c899697d4b6e1b631092ca31f6ad7a11204f0a6f0d1cfd6062324a402ee3c1e852c1c8e69b95e82eb5005bcb9cb4fcef7ebf0432a009c6be85ea911b03d3b5ea9)
 1/7: _ch0_frame = long_to_bytes(0xf3f38a716511b3bbbc253c6992e3fe692d709354c0b7c82a9f1be40c899697d4b6e1b631092ca31f6ad7a11204f0a6f0d1cfd6062324a402ee3c1e852c1c8e69b95e82eb5005bcb9cb4fcef7ebf0432a009c6be85ea911b03d3b5ea9)
 1/8: _ch0_frame[-16:]
 1/9: t1 = _ch0_frame[-16:]
1/10: a1 = b''
1/11: c1 = _ch0_frame[:-16]
1/12: ch0_frame = long_to_bytes(0xf3f38a71a0f048f1bc253c6992e3fe692d709354c0b7c82a9f1be40c899697d4b6e1b631092ca31f6ad7a1125fa3f2a286c8835a2324a402ee3c1e85794ddc6bb95bd8ed0050bae49f1cc2f1f44acc515c75d227c691d3bbc0215610)
1/13: a2 = b''
1/14: t2 = ch0_frame[-16:]
1/15: c2 = ch0_frame[:-16]
1/16: recover_possible_auth_keys(a1, c1, t1, a2, c2, t2)
1/17: x = recover_possible_auth_keys(a1, c1, t1, a2, c2, t2)
1/18: x.next()
1/19: [_ for _ in x]
1/20: x[0]
1/21: [_ for _ in x]
1/22: [*recover_possible_auth_keys(a1, c1, t1, a2, c2, t2)]
1/23: [*recover_possible_auth_keys(a1, c1, t1, a2, c2, t2)][0]
1/24: h = [*recover_possible_auth_keys(a1, c1, t1, a2, c2, t2)][0]
1/25: *recover_possible_auth_keys(a1, c1, t1, a2, c2, t2)
1/26: h
1/27: forge_tag(h, a1, c1, t1, b'', f)
1/28: f = long_to_bytes(f3f38a716511b3bbbc253c6992e3fe692d709354c0b7c82a9f1be40c899697d4b6e1b631092ca31f6ad7a11204f0a6f0d1cfd6062324a402ee3c1e852c1c8e69b95e82eb6005bcb9cb4fcef7ebf0432a009c6be85ea911b03d3b5ea9)
1/29: f = long_to_bytes(0xf3f38a716511b3bbbc253c6992e3fe692d709354c0b7c82a9f1be40c899697d4b6e1b631092ca31f6ad7a11204f0a6f0d1cfd6062324a402ee3c1e852c1c8e69b95e82eb6005bcb9cb4fcef7ebf0432a009c6be85ea911b03d3b5ea9)
1/30: forge_tag(h, a1, c1, t1, b'', f)
1/31: h
1/32: forge_tag(h, a1, c1, t1, b'', f)
1/33: f =
1/34: f = long_to_bytes(0xf3f38a71a0f048f1bc253c6992e3fe692d709354c0b7c82a9f1be40c899697E4D6e1b631092ca31f6ad7a1125fa3f2a286c8835a2324a402ee3c1e85794ddc6bb95bd8ed0050bae49f1cc2f1f44acc515c75d227c691d3bbc0215610)
1/35: forge_tag(h, a1, c1, t1, b'', f)
1/36: forge_tag(h, a1, c1, t1, b'', f)
1/37:
def forge_tag(h, a, c, t, target_a, target_c):
    """
    Forges an authentication tag for a target message given a message with a known tag.
    This method is best used with the authentication keys generated by the recover_possible_auth_keys method.
    More information: Joux A., "Authentication Failures in NIST version of GCM"
    :param h: the authentication key to use (gf2e element)
    :param a: the associated data of the message with the known tag (bytes)
    :param c: the ciphertext of the message with the known tag (bytes)
    :param t: the known authentication tag (bytes)
    :param target_a: the target associated data (bytes)
    :param target_c: the target ciphertext (bytes)
    :return: the forged authentication tag (bytes)
    """
    ghash = _from_gf2e(_ghash(h, a, c))
    target_ghash = _from_gf2e(_ghash(h, target_a, target_c))
    return (ghash ^^ int.from_bytes(t, byteorder="big") ^^ target_ghash).to_bytes(16, byteorder="big")
1/38: forge_tag(h, a1, c1, t1, b'', f)
1/39: hex(forge_tag(h, a1, c1, t1, b'', f))
1/40: hex(bytes_to_long(forge_tag(h, a1, c1, t1, b'', f)))
1/41: hex(bytes_to_long(f + forge_tag(h, a1, c1, t1, b'', f)))
1/42: f
1/43: hex(bytes_to_long(f[:-16] + forge_tag(h, a1, c1, t1, b'', f[:-16])))
1/44: f
1/45: h
1/46: c2_frame = long_to_bytes(0xf1f38a7134b7a1f0bc253c69c9eda83c79769a5987ea95609a45b053899697d4b6e1b631092ca31f6ad7a1125fa0a5f282c9d3072324a402ee3c1e85761bd93aec5cdfe8540eb9eb9d1bc7f47794509f853423017ad8a10b645722cf)
1/47: [*recover_possible_auth_keys(a1, c1, t1, a2, c2_frame[:-16], c2_frame[-16:])]
1/48: h
1/49: [*recover_possible_auth_keys(a1, c1, t1, a2, c2_frame[:-16], c2_frame[-16:])][0] == h
1/50: c1_frame = long_to_bytes(0xf2f38a7145b6a1f0bc253c6992e3fe692d709354c0b7c82a9f1be40c899697d4b6e1b631092ca31f6ad7a1125fa0a5f282cad4062324a402ee3c1e852e49da6ebb0e82ba0752b8ed9f4b94f0ff842d5fffea96bfaa5c3248705b1dd2)
1/51: [*recover_possible_auth_keys(b'', c1_frame[:-16], c1_frame[-16:], b'', c2_frame[:-16], c2_frame[-16:])]
1/52: [*recover_possible_auth_keys(b'', c1_frame[:-16], c1_frame[-16:], b'', c2_frame[:-16], c2_frame[-16:])][0] == h
1/53: a1
1/54: c1
1/55: c2
1/56: t1
1/57: forge_tag(h, a1, c1, t1, b'', long_to_bytes(0xf7f38a71b9b7a1f0bc253c699eb8a0322d20980b80ef943f9a40b101899697d4b6e1b631092ca31f6ad7a1125fa0a5f282c9800a2324a402ee3c1e857749863dbe588aef5101b3ea9817cff0c0a2c5cf1c17c43574972d081cf66030)[:-16])
1/58: forge_tag(h, a1, c1, t1, b'', long_to_bytes(0xf7f38a71b9b7a1f0bc253c699eb8a0322d20980b80ef043f9a40b101899697d4b6e1b631092ca31f6ad7a1125fa0a5f282c9800a2324a402ee3c1e857749863dbe588aef5101b3ea9817cff0c0a2c5cf1c17c43574972d081cf66030)[:-16])
1/59: hex(bytes_to_long(forge_tag(h, a1, c1, t1, b'', long_to_bytes(0xf7f38a71b9b7a1f0bc253c699eb8a0322d20980b80ef043f9a40b101899697d4b6e1b631092ca31f6ad7a1125fa0a5f282c9800a2324a402ee3c1e857749863dbe588aef5101b3ea9817cff0c0a2c5cf1c17c43574972d081cf66030)[:-16])))
1/60: hex(bytes_to_long(forge_tag(h, a1, c1, t1, b'', long_to_bytes(0xf7f38a71b9b7a1f0bc253c699eb8a0322d20980b80ef043f9a40b101899697d4b6e1b631092ca31f6ad7a1125fa0a5f282c9800a2324a402ee3c1e857749863dbe588aef5101b3ea9817cff0c0a2c5cf1c17c43574972d081cf66030)[:-16])))[2:]
1/61: hex(bytes_to_long(forge_tag(h, a1, c1, t1, b'', long_to_bytes(0xf0f38a7176b7a1f0bc253c69c5baab357e24c90b83bb96619915b05a899697d4b6e1b631092ca31f6ad7a1125fa0a5f282c9d75c2324a402ee3c1e85291d8e3eeb528cba5705e8b89a4bcef525c0dce15ca9d22fb23277e2d8ac48bc)[:-16])))[2:]
1/62: hex(bytes_to_long(forge_tag(h, a1, c1, t1, b'', long_to_bytes(0xf0f38a7176b7a1f0bc253c69c5baab357e24c90b83bb96619915b05a899697d4b6e1b631092ca31f6ad7a1125fa0a5f282c9d75c2324a402ee3c1e85291d8e3eeb528cba5705e8b89a4bcef525c0dce15ca9d22fb23277e2d8ac48bc)[:-16])))[2:] == '25c0dce15ca9d22fb23277e2d8ac48bc'
1/63: xxx = long_to_bytes(0x9724fdbeb620d2a862223c695cab2048ab70fb3ab7dfa159fc738562d7b6f1b8aa6f047eb59adc890d53fd7fe9a07247); hex(bytes_to_long(forge_tag(h, a1, c1, t1, b'', x[:-16])))[2:] == x[-16:]
1/64: xxx = long_to_bytes(0x9724fdbeb620d2a862223c695cab2048ab70fb3ab7dfa159fc738562d7b6f1b8aa6f047eb59adc890d53fd7fe9a07247); hex(bytes_to_long(forge_tag(h, a1, c1, t1, b'', xxx[:-16])))[2:] == xxx[-16:]
1/65: xxx = long_to_bytes(0xf1f38a7134b7a1f0bc253c69c9eda83c79769a5987ea95609a45b053899697d4b6e1b631092ca31f6ad7a1125fa0a5f282c9d3072324a402ee3c1e85761bd93aec5cdfe8540eb9eb9d1bc7f47794509f853423017ad8a10b645722cf); hex(bytes_to_long(forge_tag(h, a1, c1, t1, b'', xxx[:-16])))[2:] == xxx[-16:]
1/66: xxx = long_to_bytes(0xf1f38a7134b7a1f0bc253c69c9eda83c79769a5987ea95609a45b053899697d4b6e1b631092ca31f6ad7a1125fa0a5f282c9d3072324a402ee3c1e85761bd93aec5cdfe8540eb9eb9d1bc7f47794509f853423017ad8a10b645722cf); hex(bytes_to_long(forge_tag(h, a1, c1, t1, b'', xxx[:-16])))[2:] == bytes_to_long(xxx[-16:])
1/67: xxx = long_to_bytes(0xf1f38a7134b7a1f0bc253c69c9eda83c79769a5987ea95609a45b053899697d4b6e1b631092ca31f6ad7a1125fa0a5f282c9d3072324a402ee3c1e85761bd93aec5cdfe8540eb9eb9d1bc7f47794509f853423017ad8a10b645722cf); hex(bytes_to_long(forge_tag(h, a1, c1, t1, b'', xxx[:-16])))[2:] == hex(bytes_to_long(xxx[-16:]))[2:]
1/68: xxx = long_to_bytes(0x9724fdbeb620d2a862223c695cab2048ab70fb3ab7dfa159fc738562d7b6f1b8aa6f047eb59adc890d53fd7fe9a07247); hex(bytes_to_long(forge_tag(h, a1, c1, t1, b'', xxx[:-16])))[2:] == hex(bytes_to_long(xxx[-16:]))[2:]
1/69: xxx = long_to_bytes(0x8724fdbeb620d2a862223c695cab2048ab70fb3ab7dfa159fc738562d7b6f1b8aa6f047eb59adc890d53fd7fe9a07247); hex(bytes_to_long(forge_tag(h, a1, c1, t1, b'', xxx[:-16])))[2:]
1/70: xxx = long_to_bytes(0x8724fdbeb620d2a862223c695cab2048ab70fb3ab7dfa159fc738562d7b6f1b8aa6f047eb59adc890d53fd7fe9a07247); hex(bytes_to_long(xxx[:-16]forge_tag(h, a1, c1, t1, b'', xxx[:-16])))[2:]
1/71: xxx = long_to_bytes(0x8724fdbeb620d2a862223c695cab2048ab70fb3ab7dfa159fc738562d7b6f1b8aa6f047eb59adc890d53fd7fe9a07247); hex(bytes_to_long(xxx[:-16]+forge_tag(h, a1, c1, t1, b'', xxx[:-16])))[2:]
1/72: xxx = long_to_bytes(0x9724fdbeb620d2a862223c695cab2048ab70fb3ab7dfa159fc738562d7b6f1b8aa6f047eb59adc890d53fd7fe9a07247); hex(bytes_to_long(xxx[:-16]+forge_tag(h, a1, c1, t1, b'', xxx[:-16])))[2:]
1/73: xxx = long_to_bytes(0xf3f38a71a0f048f1bc253c6992e3fe692d609354c0b7c82a9f1be40c899697d4b6e1b631092ca31f6ad7a1125fa3f2a286c8835a2324a402ee3c1e85794ddc6bb95bd8ed0050bae49f1cc2f1f44acc515c75d227c691d3bbc0215610); hex(bytes_to_long(xxx[:-16]+forge_tag(h, a1, c1, t1, b'', xxx[:-16])))[2:]
   1: %history -g